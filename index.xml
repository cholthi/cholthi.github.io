<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Chol Paul</title>
    <link>/</link>
    <description>Recent content on Chol Paul</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>&amp;copy; 2019 Chol Paul</copyright>
    <lastBuildDate>Sat, 07 Mar 2020 22:16:01 +0300</lastBuildDate>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Fun With Golang Formatted Scanning</title>
      <link>/blog/fun-with-golang-formatted-scanning/</link>
      <pubDate>Sat, 07 Mar 2020 22:16:01 +0300</pubDate>
      
      <guid>/blog/fun-with-golang-formatted-scanning/</guid>
      <description>Go&#39;s fmt package is the power house of formatted IO. It centralizes string formating routines for simple tasks as echoing to standard output to more complex such as sending formatted data to network IO. In fact, your first encounter with Go langange may involve use of fmt package.
import &amp;#34;fmt&amp;#34; greeting := &amp;#34;Hello World&amp;#34; fmt.Println(greeting) // prints &amp;#34;Hello World&amp;#34; to stdout Receving user input is daunting and an area full of security holes.</description>
    </item>
    
    <item>
      <title>Explicit Arguments Indexes With Fmt Package</title>
      <link>/blog/explicit-arguments-indexes-with-fmt-package/</link>
      <pubDate>Wed, 08 Jan 2020 21:50:06 +0300</pubDate>
      
      <guid>/blog/explicit-arguments-indexes-with-fmt-package/</guid>
      <description>Golang has a very handy package called fmt for formating data values.
fmt.Printf(&amp;#34;Hello %s&amp;#34;, &amp;#34;world&amp;#34;) // Hello World But by default, the fmt family of functions work by successively applying args passed after the format string to matching format verbs by argument order.
tablePrefix := &amp;#34;mydb&amp;#34; query := fmt.Sprintf(&amp;#34;SELECT %s_table1.*, %s_table2.id from %s_table1 left join %s_table2 on %s_table2.id = %s_table1.id;&amp;#34;,tablePrefix, tablePrefix, tablePrefix, tablePrefix, tablePrefix) fmt.Print(query) // SELECT mydb_table1.*, mydb_table2.id from mydb_table1 left join mydb_table2 on mydb_table2.</description>
    </item>
    
    <item>
      <title>Deleting Slice Item</title>
      <link>/blog/deleting-slice-item/</link>
      <pubDate>Thu, 24 Oct 2019 13:08:45 +0300</pubDate>
      
      <guid>/blog/deleting-slice-item/</guid>
      <description>n Go, a slice is a fundamental data structure, it is a mutable Homogeneous array. It can grow and shrink at run time according to the needs of application.You can think of as it as Vector class if youâ€™re coming from a Java background.
Often time while working with slices, you would like to add elements to a slice.
var s []string = make([]string, 0) s = append(s,&amp;#39;cairo&amp;#39;) // adds to the end Today, I want to share a common idiom in Go on how to remove an element by its index.</description>
    </item>
    
    <item>
      <title>Go Slice Expressions</title>
      <link>/blog/go-slice-expressions/</link>
      <pubDate>Fri, 09 Aug 2019 12:57:11 +0300</pubDate>
      
      <guid>/blog/go-slice-expressions/</guid>
      <description>Go allows operation on slices to extract part of its elements using a beautiful syntax. Go calls it Slice Expressions.
var s []Type s[low:high] Here is how the official Go langange specs define Slice Expressions.
 For a string, array, pointer to array, or slice a, the primary expression a[low : high] constructs a substring or slice. The indices low and high select which elements of operand a appear in the result.</description>
    </item>
    
    <item>
      <title>Listing Dependencies of Packages</title>
      <link>/blog/listing-dependencies-of-packages/</link>
      <pubDate>Mon, 10 Jun 2019 12:42:05 +0300</pubDate>
      
      <guid>/blog/listing-dependencies-of-packages/</guid>
      <description>There is a fantastic tool in the Go eco system called go list. This tool uses Go template package and comes with comes a set of predefined template variables we can use to format its output.
Here we will use it to list the dependencies of our local package.
Lets assume we are working on html scrapping package called scrappy
Listing all packages $ go list -f &amp;#39;{{ .Imports }}&amp;#39; github.</description>
    </item>
    
    <item>
      <title>Manis Hugo Theme</title>
      <link>/work/manis-hugo-theme/</link>
      <pubDate>Sat, 24 Jun 2017 20:47:35 +0700</pubDate>
      
      <guid>/work/manis-hugo-theme/</guid>
      <description>It&#39;s a minimalist and responsive theme for Hugo Static Site Generator. It&#39;s name taken from Indonesian Language for Sweet.
Features Like I said, it&#39;s really minimal. Its doesn&#39;t even have grid or anything nice like that.
 Configurable color! Code Highlighting (HighlightJS). Responsive. Social Icon Links. No Grid no worry. Translatable.  </description>
    </item>
    
  </channel>
</rss>